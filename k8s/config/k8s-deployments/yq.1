.\" Automatically generated by Pandoc 2.14.2
.\"
.TH "YQ" "1" "" "" "yq (https://github.com/mikefarah/yq/) version v4.14.2"
.hy
.SH NAME
.PP
\f[I]yq\f[R] is a portable command-line YAML processor
.SH SYNOPSIS
.PP
yq [eval/eval-all] [expression] files..
.PP
eval/e - Apply the expression to each document in each yaml file in
sequence
.PP
eval-all/ea - Loads all yaml documents of all yaml files and runs
expression once
.SH DESCRIPTION
.PP
a lightweight and portable command-line YAML processor.
\f[C]yq\f[R] uses jq (https://github.com/stedolan/jq) like syntax but
works with yaml files as well as json.
It doesn\[cq]t yet support everything \f[C]jq\f[R] does - but it does
support the most common operations and functions, and more is being
added continuously.
.PP
This documentation is also available at https://mikefarah.gitbook.io/yq/
# QUICK GUIDE
.SS Read a value:
.IP
.nf
\f[C]
yq e \[aq].a.b[0].c\[aq] file.yaml
\f[R]
.fi
.SS Pipe from STDIN:
.IP
.nf
\f[C]
cat file.yaml | yq e \[aq].a.b[0].c\[aq] -
\f[R]
.fi
.SS Update a yaml file, inplace
.IP
.nf
\f[C]
yq e -i \[aq].a.b[0].c = \[dq]cool\[dq]\[aq] file.yaml
\f[R]
.fi
.SS Update using environment variables
.IP
.nf
\f[C]
NAME=mike yq e -i \[aq].a.b[0].c = strenv(NAME)\[aq] file.yaml
\f[R]
.fi
.SS Merge multiple files
.IP
.nf
\f[C]
yq ea \[aq]. as $item ireduce ({}; . * $item )\[aq] path/to/*.yml
\f[R]
.fi
.SS Multiple updates to a yaml file
.IP
.nf
\f[C]
yq e -i \[aq]
  .a.b[0].c = \[dq]cool\[dq] |
  .x.y.z = \[dq]foobar\[dq] |
  .person.name = strenv(NAME)
\[aq] file.yaml
\f[R]
.fi
.PP
See the documentation (https://mikefarah.gitbook.io/yq/) for more.
.SH KNOWN ISSUES / MISSING FEATURES
.IP \[bu] 2
\f[C]yq\f[R] attempts to preserve comment positions and whitespace as
much as possible, but it does not handle all scenarios (see
https://github.com/go-yaml/yaml/tree/v3 for details)
.IP \[bu] 2
Powershell has its own\&...opinions:
https://mikefarah.gitbook.io/yq/usage/tips-and-tricks#quotes-in-windows-powershell
.SH BUGS / ISSUES / FEATURE REQUESTS
.PP
Please visit the GitHub page https://github.com/mikefarah/yq/.
.SH HOW IT WORKS
.PP
In \f[C]yq\f[R] expressions are made up of operators and pipes.
A context of nodes is passed through the expression and each operation
takes the context as input and returns a new context as output.
That output is piped in as input for the next operation in the
expression.
To begin with, the context is set to the first yaml document of the
first yaml file (if processing in sequence using eval).
.PP
Lets look at a couple of examples.
.SS Simple assignment example
.PP
Given a document like:
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.PP
with an expression:
.IP
.nf
\f[C]
\&.a = .b
\f[R]
.fi
.PP
Like math expression - operator precedence is important.
.PP
The \f[C]=\f[R] operator takes two arguments, a \f[C]lhs\f[R]
expression, which in this case is \f[C].a\f[R] and \f[C]rhs\f[R]
expression which is \f[C].b\f[R].
.PP
It pipes the current, lets call it `root' context through the
\f[C]lhs\f[R] expression of \f[C].a\f[R] to return the node
.IP
.nf
\f[C]
cat
\f[R]
.fi
.PP
Sidenote: this node holds not only its value `cat', but comments and
metadata too, including path and parent information.
.PP
The \f[C]=\f[R] operator then pipes the `root' context through the
\f[C]rhs\f[R] expression of \f[C].b\f[R] to return the node
.IP
.nf
\f[C]
dog
\f[R]
.fi
.PP
Both sides have now been evaluated, so now the operator copies across
the value from the RHS (\f[C].b\f[R]) to the the LHS (\f[C].a\f[R]), and
it returns the now updated context:
.IP
.nf
\f[C]
a: dog
b: dog
\f[R]
.fi
.SS Complex assignment, operator precedence rules
.PP
Just like math expression - \f[C]yq\f[R] expression have an order of
precedence.
The pipe \f[C]|\f[R] operator has a low order of precedence, so
operators with higher precedence will get evalated first.
.PP
Most of the time, this is intuitively what you\[cq]d want, for instance
\f[C].a = \[dq]cat\[dq] | .b = \[dq]dog\[dq]\f[R] is effectively:
\f[C](.a = \[dq]cat\[dq]) | (.b = \[dq]dog\[dq])\f[R].
.PP
However, this is not always the case, particularly if you have a complex
LHS or RHS expression, for instance if you want to select particular
nodes to update.
.PP
Lets say you had:
.IP
.nf
\f[C]
- name: bob
  fruit: apple
- name: sally
  fruit: orange
\f[R]
.fi
.PP
Lets say you wanted to update the \f[C]sally\f[R] entry to have fruit:
`mango'.
The \f[I]incorrect\f[R] way to do that is:
\f[C].[] | select(.name == \[dq]sally\[dq]) | .fruit = \[dq]mango\[dq]\f[R].
.PP
Becasue \f[C]|\f[R] has a low operator precedence, this will be
evaluated (\f[I]incorrectly\f[R]) as :
\f[C](.[]) | (select(.name == \[dq]sally\[dq])) | (.fruit = \[dq]mango\[dq])\f[R].
What you\[cq]ll see is only the updated segment returned:
.IP
.nf
\f[C]
name: sally
fruit: mango
\f[R]
.fi
.PP
To properly update this yaml, you will need to use brackets (think
BODMAS from maths) and wrap the entire LHS:
\f[C](.[] | select(.name == \[dq]sally\[dq]) | .fruit) = \[dq]mango\[dq]\f[R]
.PP
Now that entire LHS expression is passed to the `assign' (\f[C]=\f[R])
operator, and the yaml is correctly updated and returned:
.IP
.nf
\f[C]
- name: bob
  fruit: apple
- name: sally
  fruit: mango
\f[R]
.fi
.SS Relative update (e.g.\ \f[C]|=\f[R])
.PP
There is another form of the \f[C]=\f[R] operator which we call the
relative form.
It\[cq]s very similar to \f[C]=\f[R] but with one key difference when
evaluating the RHS expression.
.PP
In the plain form, we pass in the `root' level context to the RHS
expression.
In relative form, we pass in \f[I]each result of the LHS\f[R] to the RHS
expression.
Let\[cq]s go through an example.
.PP
Given a document like:
.IP
.nf
\f[C]
a: 1
b: thing
\f[R]
.fi
.PP
with an expression:
.IP
.nf
\f[C]
\&.a |= . + 1
\f[R]
.fi
.PP
Similar to the \f[C]=\f[R] operator, \f[C]|=\f[R] takes two operands,
the LHS and RHS.
.PP
It pipes the current context (the whole document) through the LHS
expression of \f[C].a\f[R] to get the node value:
.IP
.nf
\f[C]
1
\f[R]
.fi
.PP
Now it pipes \f[I]that LHS context\f[R] into the RHS expression
\f[C]. + 1\f[R] (whereas in the \f[C]=\f[R] plain form it piped the
original document context into the RHS) to yield:
.IP
.nf
\f[C]
2
\f[R]
.fi
.PP
The assignment operator then copies across the value from the RHS to the
value on the LHS, and it returns the now updated `root' context:
.IP
.nf
\f[C]
a: 2
b: thing
\f[R]
.fi
.SH Add
.PP
Add behaves differently according to the type of the LHS: * arrays:
concatenate * number scalars: arithmetic addition * string scalars:
concatenate
.PP
Use \f[C]+=\f[R] as append assign for things like increment.
Note that \f[C].a += .x\f[R] is equivalent to running
\f[C].a = .a + .x\f[R].
.SS Concatenate and assign arrays
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  val: thing
  b:
    - cat
    - dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.b += [\[dq]cow\[dq]]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  val: thing
  b:
    - cat
    - dog
    - cow
\f[R]
.fi
.SS Concatenate arrays
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - 1
  - 2
b:
  - 3
  - 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a + .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 2
- 3
- 4
\f[R]
.fi
.SS Concatenate null to array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - 1
  - 2
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a + null\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 2
\f[R]
.fi
.SS Add new object to array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - dog: woof
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a + {\[dq]cat\[dq]: \[dq]meow\[dq]}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- dog: woof
- cat: meow
\f[R]
.fi
.SS Add string to array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - 1
  - 2
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a + \[dq]hello\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 2
- hello
\f[R]
.fi
.SS Append to array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - 1
  - 2
b:
  - 3
  - 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a = .a + .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  - 1
  - 2
  - 3
  - 4
b:
  - 3
  - 4
\f[R]
.fi
.SS Append another array using +=
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - 1
  - 2
b:
  - 3
  - 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a += .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  - 1
  - 2
  - 3
  - 4
b:
  - 3
  - 4
\f[R]
.fi
.SS Relative append
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  a1:
    b:
      - cat
  a2:
    b:
      - dog
  a3: {}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a[].b += [\[dq]mouse\[dq]]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  a1:
    b:
      - cat
      - mouse
  a2:
    b:
      - dog
      - mouse
  a3: {b: [mouse]}
\f[R]
.fi
.SS String concatenation
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: meow
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a = .a + .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: catmeow
b: meow
\f[R]
.fi
.SS Number addition - float
.PP
If the lhs or rhs are floats then the expression will be calculated with
floats.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 4.9
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a = .a + .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 7.9
b: 4.9
\f[R]
.fi
.SS Number addition - int
.PP
If both the lhs and rhs are ints then the expression will be calculated
with ints.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a = .a + .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 7
b: 4
\f[R]
.fi
.SS Increment numbers
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] += 1\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 4
b: 6
\f[R]
.fi
.SS Add to null
.PP
Adding to null simply returns the rhs
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]null + \[dq]cat\[dq]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
\f[R]
.fi
.SH Alternative (Default value)
.PP
This operator is used to provide alternative (or default) values when a
particular expression is either null or false.
.SS LHS is defined
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: bridge
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a // \[dq]hello\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
bridge
\f[R]
.fi
.SS LHS is not defined
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
{}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a // \[dq]hello\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
hello
\f[R]
.fi
.SS LHS is null
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: \[ti]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a // \[dq]hello\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
hello
\f[R]
.fi
.SS LHS is false
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: false
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a // \[dq]hello\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
hello
\f[R]
.fi
.SS RHS is an expression
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: false
b: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a // .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
\f[R]
.fi
.SH Anchor and Alias Operators
.PP
Use the \f[C]alias\f[R] and \f[C]anchor\f[R] operators to read and write
yaml aliases and anchors.
The \f[C]explode\f[R] operator normalises a yaml file (dereference (or
expands) aliases and remove anchor names).
.PP
\f[C]yq\f[R] supports merge aliases (like \f[C]<<: *blah\f[R]) however
this is no longer in the standard yaml spec (1.2) and so \f[C]yq\f[R]
will automatically add the \f[C]!!merge\f[R] tag to these nodes as it is
effectively a custom tag.
.SS Merge one map
.PP
see https://yaml.org/type/merge.html
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- &CENTER
  x: 1
  y: 2
- &LEFT
  x: 0
  y: 2
- &BIG
  r: 10
- &SMALL
  r: 1
- !!merge <<: *CENTER
  r: 10
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[4] | explode(.)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
x: 1
y: 2
r: 10
\f[R]
.fi
.SS Merge multiple maps
.PP
see https://yaml.org/type/merge.html
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- &CENTER
  x: 1
  y: 2
- &LEFT
  x: 0
  y: 2
- &BIG
  r: 10
- &SMALL
  r: 1
- !!merge <<:
    - *CENTER
    - *BIG
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[4] | explode(.)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
r: 10
x: 1
y: 2
\f[R]
.fi
.SS Override
.PP
see https://yaml.org/type/merge.html
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- &CENTER
  x: 1
  y: 2
- &LEFT
  x: 0
  y: 2
- &BIG
  r: 10
- &SMALL
  r: 1
- !!merge <<:
    - *BIG
    - *LEFT
    - *SMALL
  x: 1
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[4] | explode(.)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
r: 10
x: 1
y: 2
\f[R]
.fi
.SS Get anchor
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: &billyBob cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a | anchor\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
billyBob
\f[R]
.fi
.SS Set anchor
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a anchor = \[dq]foobar\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: &foobar cat
\f[R]
.fi
.SS Set anchor relatively using assign-update
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a anchor |= .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: &cat
  b: cat
\f[R]
.fi
.SS Get alias
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
b: &billyBob meow
a: *billyBob
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a | alias\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
billyBob
\f[R]
.fi
.SS Set alias
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
b: &meow purr
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a alias = \[dq]meow\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b: &meow purr
a: *meow
\f[R]
.fi
.SS Set alias to blank does nothing
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
b: &meow purr
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a alias = \[dq]\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b: &meow purr
a: cat
\f[R]
.fi
.SS Set alias relatively using assign-update
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
b: &meow purr
a:
  f: meow
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a alias |= .f\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b: &meow purr
a: *meow
\f[R]
.fi
.SS Explode alias and anchor
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
f:
  a: &a cat
  b: *a
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]explode(.f)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
f:
  a: cat
  b: cat
\f[R]
.fi
.SS Explode with no aliases or anchors
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: mike
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]explode(.a)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: mike
\f[R]
.fi
.SS Explode with alias keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
f:
  a: &a cat
  *a: b
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]explode(.f)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
f:
  a: cat
  cat: b
\f[R]
.fi
.SS Explode with merge anchors
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]explode(.)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
foo:
  a: foo_a
  thing: foo_thing
  c: foo_c
bar:
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: bar_b
  thing: foo_thing
  c: foobarList_c
  a: foo_a
foobar:
  c: foo_c
  a: foo_a
  thing: foobar_thing
\f[R]
.fi
.SS Dereference and update a field
.PP
\[ga]Use explode with multiply to dereference an object
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
item_value: &item_value
  value: true
thingOne:
  name: item_1
  !!merge <<: *item_value
thingTwo:
  name: item_2
  !!merge <<: *item_value
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].thingOne |= explode(.) * {\[dq]value\[dq]: false}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
item_value: &item_value
  value: true
thingOne:
  name: item_1
  value: false
thingTwo:
  name: item_2
  !!merge <<: *item_value
\f[R]
.fi
.SH Assign (Update)
.PP
This operator is used to update node values.
It can be used in either the:
.SS plain form: \f[C]=\f[R]
.PP
Which will assign the LHS node values to the RHS node values.
The RHS expression is run against the matching nodes in the pipeline.
.SS relative form: \f[C]|=\f[R]
.PP
This will do a similar thing to the plain form, however, the RHS
expression is run against \f[I]the LHS nodes\f[R].
This is useful for updating values based on old values, e.g.\ increment.
## Create yaml file Running
.IP
.nf
\f[C]
yq eval --null-input \[aq].a.b = \[dq]cat\[dq] | .x = \[dq]frog\[dq]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: cat
x: frog
\f[R]
.fi
.SS Update node to be the child value
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b:
    g: foof
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a |= .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  g: foof
\f[R]
.fi
.SS Double elements in an array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] |= . * 2\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 2
- 4
- 6
\f[R]
.fi
.SS Update node from another file
.PP
Note this will also work when the second file is a scalar
(string/number)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: apples
\f[R]
.fi
.PP
And another sample another.yml file of:
.IP
.nf
\f[C]
b: bob
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval-all \[aq]select(fileIndex==0).a = select(fileIndex==1) | select(fileIndex==0)\[aq] sample.yml another.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: bob
\f[R]
.fi
.SS Update node to be the sibling value
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: child
b: sibling
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a = .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: sibling
b: sibling
\f[R]
.fi
.SS Updated multiple paths
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: fieldA
b: fieldB
c: fieldC
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq](.a, .c) = \[dq]potatoe\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: potatoe
b: fieldB
c: potatoe
\f[R]
.fi
.SS Update string value
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.b = \[dq]frog\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: frog
\f[R]
.fi
.SS Update string value via |=
.PP
Note there is no difference between \f[C]=\f[R] and \f[C]|=\f[R] when
the RHS is a scalar
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.b |= \[dq]frog\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: frog
\f[R]
.fi
.SS Update deeply selected results
.PP
Note that the LHS is wrapped in brackets! This is to ensure we dont
first filter out the yaml and then update the snippet.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: apple
  c: cactus
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq](.a[] | select(. == \[dq]apple\[dq])) = \[dq]frog\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: frog
  c: cactus
\f[R]
.fi
.SS Update array values
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- candy
- apple
- sandy
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq](.[] | select(. == \[dq]*andy\[dq])) = \[dq]bogs\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- bogs
- apple
- bogs
\f[R]
.fi
.SS Update empty object
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
{}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.b |= \[dq]bogs\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
{a: {b: bogs}}
\f[R]
.fi
.SS Update empty object and array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
{}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.b.[0] |= \[dq]bogs\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
{a: {b: [bogs]}}
\f[R]
.fi
.SH Boolean Operators
.PP
The \f[C]or\f[R] and \f[C]and\f[R] operators take two parameters and
return a boolean result.
.PP
\f[C]not\f[R] flips a boolean from true to false, or vice versa.
.PP
\f[C]any\f[R] will return \f[C]true\f[R] if there are any \f[C]true\f[R]
values in a array sequence, and \f[C]all\f[R] will return true if
\f[I]all\f[R] elements in an array are true.
.PP
\f[C]any_c(condition)\f[R] and \f[C]all_c(condition)\f[R] are like
\f[C]any\f[R] and \f[C]all\f[R] but they take a condition expression
that is used against each element to determine if it\[cq]s
\f[C]true\f[R].
Note: in \f[C]jq\f[R] you can simply pass a condition to \f[C]any\f[R]
or \f[C]all\f[R] and it simply works - \f[C]yq\f[R] isn\[cq]t that
clever..yet
.PP
These are most commonly used with the \f[C]select\f[R] operator to
filter particular nodes.
.SS \f[C]or\f[R] example
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]true or false\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS \f[C]and\f[R] example
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]true and false\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS Matching nodes with select, equals and or
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: bird
  b: dog
- a: frog
  b: bird
- a: cat
  b: fly
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq][.[] | select(.a == \[dq]cat\[dq] or .b == \[dq]dog\[dq])]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a: bird
  b: dog
- a: cat
  b: fly
\f[R]
.fi
.SS \f[C]any\f[R] returns true if any boolean in a given array is true
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- false
- true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]any\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS \f[C]any\f[R] returns false for an empty array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
[]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]any\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS \f[C]any_c\f[R] returns true if any element in the array is true for the given condition.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - rad
  - awesome
b:
  - meh
  - whatever
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] |= any_c(. == \[dq]awesome\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: true
b: false
\f[R]
.fi
.SS \f[C]all\f[R] returns true if all booleans in a given array are true
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- true
- true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]all\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS \f[C]all\f[R] returns true for an empty array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
[]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]all\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS \f[C]all_c\f[R] returns true if all elements in the array are true for the given condition.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - rad
  - awesome
b:
  - meh
  - 12
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] |= all_c(tag == \[dq]!!str\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: true
b: false
\f[R]
.fi
.SS Not true is false
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]true | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS Not false is true
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]false | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS String values considered to be true
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]\[dq]cat\[dq] | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS Empty string value considered to be true
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]\[dq]\[dq] | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS Numbers are considered to be true
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]1 | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS Zero is considered to be true
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]0 | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS Null is considered to be false
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]\[ti] | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SH Collect into Array
.PP
This creates an array using the expression between the square brackets.
.SS Collect empty
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq][]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
[]
\f[R]
.fi
.SS Collect single
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq][\[dq]cat\[dq]]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- cat
\f[R]
.fi
.SS Collect many
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq][.a, .b]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- cat
- dog
\f[R]
.fi
.SH Comment Operators
.PP
Use these comment operators to set or retrieve comments.
.PP
Like the \f[C]=\f[R] and \f[C]|=\f[R] assign operators, the same syntax
applies when updating comments:
.SS plain form: \f[C]=\f[R]
.PP
This will assign the LHS nodes comments to the expression on the RHS.
The RHS is run against the matching nodes in the pipeline
.SS relative form: \f[C]|=\f[R]
.PP
Similar to the plain form, however the RHS evaluates against each
matching LHS node! This is useful if you want to set the comments as a
relative expression of the node, for instance its value or path.
.SS Set line comment
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a lineComment=\[dq]single\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat # single
\f[R]
.fi
.SS Use update assign to perform relative updates
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].. lineComment |= .\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat # cat
b: dog # dog
\f[R]
.fi
.SS Set head comment
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]. headComment=\[dq]single\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
# single

a: cat
\f[R]
.fi
.SS Set foot comment, using an expression
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]. footComment=.a\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat

# cat
\f[R]
.fi
.SS Remove comment
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat # comment
b: dog # leave this
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a lineComment=\[dq]\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b: dog # leave this
\f[R]
.fi
.SS Remove (strip) all comments
.PP
Note the use of \f[C]...\f[R] to ensure key nodes are included.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat # comment
# great
b: # key comment
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]... comments=\[dq]\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b:
\f[R]
.fi
.SS Get line comment
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat # meow
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a | lineComment\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
meow
\f[R]
.fi
.SS Get head comment
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
# welcome!

a: cat # meow

# have a great day
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]. | headComment\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
welcome!
\f[R]
.fi
.SS 
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
# welcome!
---
# bob
a: cat # meow

# have a great day
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]headComment\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
welcome!
bob
\f[R]
.fi
.SS Get foot comment
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
# welcome!

a: cat # meow

# have a great day
# no really
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]. | footComment\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
have a great day
no really
\f[R]
.fi
.SH Contains
.PP
This returns \f[C]true\f[R] if the context contains the passed in
parameter, and false otherwise.
.SS Array contains array
.PP
Array is equal or subset of
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- foobar
- foobaz
- blarp
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]contains([\[dq]baz\[dq], \[dq]bar\[dq]])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS Object included in array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
\[dq]foo\[dq]: 12
\[dq]bar\[dq]:
  - 1
  - 2
  - \[dq]barp\[dq]: 12
    \[dq]blip\[dq]: 13
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]contains({\[dq]bar\[dq]: [{\[dq]barp\[dq]: 12}]})\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS Object not included in array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
\[dq]foo\[dq]: 12
\[dq]bar\[dq]:
  - 1
  - 2
  - \[dq]barp\[dq]: 12
    \[dq]blip\[dq]: 13
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]contains({\[dq]foo\[dq]: 12, \[dq]bar\[dq]: [{\[dq]barp\[dq]: 15}]})\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS String contains substring
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foobar
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]contains(\[dq]bar\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS String equals string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
meow
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]contains(\[dq]meow\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SH Create, Collect into Object
.PP
This is used to construct objects (or maps).
This can be used against existing yaml, or to create fresh yaml
documents.
.SS Collect empty object
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]{}\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
{}
\f[R]
.fi
.SS Wrap (prefix) existing object
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
name: Mike
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]{\[dq]wrap\[dq]: .}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
wrap:
  name: Mike
\f[R]
.fi
.SS Using splat to create multiple objects
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
name: Mike
pets:
  - cat
  - dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]{.name: .pets.[]}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
Mike: cat
Mike: dog
\f[R]
.fi
.SS Working with multiple documents
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
name: Mike
pets:
  - cat
  - dog
---
name: Rosey
pets:
  - monkey
  - sheep
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]{.name: .pets.[]}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
Mike: cat
Mike: dog
Rosey: monkey
Rosey: sheep
\f[R]
.fi
.SS Creating yaml from scratch
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]{\[dq]wrap\[dq]: \[dq]frog\[dq]}\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
wrap: frog
\f[R]
.fi
.SH Delete
.PP
Deletes matching entries in maps or arrays.
.SS Delete entry in map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]del(.b)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.SS Delete nested entry in map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  a1: fred
  a2: frood
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]del(.a.a1)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  a2: frood
\f[R]
.fi
.SS Delete entry in array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]del(.[1])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 3
\f[R]
.fi
.SS Delete nested entry in array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: cat
  b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]del(.[0].a)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- b: dog
\f[R]
.fi
.SS Delete no matches
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]del(.c)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.SS Delete matching entries
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: dog
c: bat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]del( .[] | select(. == \[dq]*at\[dq]) )\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b: dog
\f[R]
.fi
.SS Recursively delete matching keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  name: frog
  b:
    name: blog
    age: 12
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]del(.. | select(has(\[dq]name\[dq])).name)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b:
    age: 12
\f[R]
.fi
.SH Document Index
.PP
Use the \f[C]documentIndex\f[R] operator (or the \f[C]di\f[R] shorthand)
to select nodes of a particular document.
.SS Retrieve a document index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
---
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a | documentIndex\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
---
1
\f[R]
.fi
.SS Retrieve a document index, shorthand
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
---
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a | di\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
---
1
\f[R]
.fi
.SS Filter by document index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
---
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]select(documentIndex == 1)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.SS Filter by document index shorthand
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
---
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]select(di == 1)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.SS Print Document Index with matches
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
---
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a | ({\[dq]match\[dq]: ., \[dq]doc\[dq]: documentIndex})\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
match: cat
doc: 0
match: frog
doc: 1
\f[R]
.fi
.SH Encoder / Decoder
.PP
Encode operators will take the piped in object structure and encode it
as a string in the desired format.
The decode operators do the opposite, they take a formatted string and
decode it into the relevant object structure.
.PP
Note that you can optionally pass an indent value to the encode
functions (see below).
.PP
These operators are useful to process yaml documents that have
stringified embeded yaml/json/props in them.
.SS Encode value as yaml string
.PP
Indent defaults to 2
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool:
    bob: dylan
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].b = (.a | to_yaml)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  cool:
    bob: dylan
b: |
  cool:
    bob: dylan
\f[R]
.fi
.SS Encode value as yaml string, with custom indentation
.PP
You can specify the indentation level as the first parameter.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool:
    bob: dylan
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].b = (.a | to_yaml(8))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  cool:
    bob: dylan
b: |
  cool:
          bob: dylan
\f[R]
.fi
.SS Encode value as yaml string, using toyaml
.PP
Does the same thing as to_yaml, matching jq naming convention.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool: thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].b = (.a | to_yaml)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  cool: thing
b: |
  cool: thing
\f[R]
.fi
.SS Encode value as json string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool: thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].b = (.a | to_json)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  cool: thing
b: |
  {
    \[dq]cool\[dq]: \[dq]thing\[dq]
  }
\f[R]
.fi
.SS Encode value as json string, on one line
.PP
Pass in a 0 indent to print json on a single line.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool: thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].b = (.a | to_json(0))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  cool: thing
b: \[aq]{\[dq]cool\[dq]:\[dq]thing\[dq]}\[aq]
\f[R]
.fi
.SS Encode value as props string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool: thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].b = (.a | to_props)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  cool: thing
b: |
  cool = thing
\f[R]
.fi
.SS Decode a yaml encoded string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: \[aq]foo: bar\[aq]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].b = (.a | from_yaml)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[aq]foo: bar\[aq]
b:
  foo: bar
\f[R]
.fi
.SS Update a multiline encoded yaml string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: |
  foo: bar
  baz: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a |= (from_yaml | .foo = \[dq]cat\[dq] | to_yaml)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: |
  foo: cat
  baz: dog
\f[R]
.fi
.SS Update a single line encoded yaml string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: \[aq]foo: bar\[aq]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a |= (from_yaml | .foo = \[dq]cat\[dq] | to_yaml)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[aq]foo: cat\[aq]
\f[R]
.fi
.SH Entries
.PP
Similar to the same named functions in \f[C]jq\f[R] these functions
convert to/from an object and an array of key-value pairs.
This is most useful for performing operations on keys of maps.
.SS to_entries Map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 1
b: 2
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]to_entries\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- key: a
  value: 1
- key: b
  value: 2
\f[R]
.fi
.SS to_entries Array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a
- b
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]to_entries\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- key: 0
  value: a
- key: 1
  value: b
\f[R]
.fi
.SS to_entries null
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
null
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]to_entries\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\f[R]
.fi
.SS from_entries map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 1
b: 2
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]to_entries | from_entries\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 1
b: 2
\f[R]
.fi
.SS from_entries with numeric key indexes
.PP
from_entries always creates a map, even for numeric keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a
- b
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]to_entries | from_entries\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0: a
1: b
\f[R]
.fi
.SS Use with_entries to update keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 1
b: 2
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]with_entries(.key |= \[dq]KEY_\[dq] + .)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
KEY_a: 1
KEY_b: 2
\f[R]
.fi
.SS Use with_entries to filter the map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: bird
c:
  d: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]with_entries(select(.value | has(\[dq]b\[dq])))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: bird
\f[R]
.fi
.SH Env Variable Operators
.PP
This operator is used to handle environment variables usage in path
expressions.
While environment variables can, of course, be passed in via your CLI
with string interpolation, this often comes with complex quote escaping
and can be tricky to write and read.
Note that there are two forms, \f[C]env\f[R] which will parse the
environment variable as a yaml (be it a map, array, string, number of
boolean) and \f[C]strenv\f[R] which will always parse the argument as a
string.
.SS Read string environment variable
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]cat meow\[dq] yq eval --null-input \[aq].a = env(myenv)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat meow
\f[R]
.fi
.SS Read boolean environment variable
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]true\[dq] yq eval --null-input \[aq].a = env(myenv)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: true
\f[R]
.fi
.SS Read numeric environment variable
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]12\[dq] yq eval --null-input \[aq].a = env(myenv)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 12
\f[R]
.fi
.SS Read yaml environment variable
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]{b: fish}\[dq] yq eval --null-input \[aq].a = env(myenv)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: {b: fish}
\f[R]
.fi
.SS Read boolean environment variable as a string
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]true\[dq] yq eval --null-input \[aq].a = strenv(myenv)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[dq]true\[dq]
\f[R]
.fi
.SS Read numeric environment variable as a string
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]12\[dq] yq eval --null-input \[aq].a = strenv(myenv)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[dq]12\[dq]
\f[R]
.fi
.SS Dynamic key lookup with environment variable
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat: meow
dog: woof
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
myenv=\[dq]cat\[dq] yq eval \[aq].[env(myenv)]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
meow
\f[R]
.fi
.SH Equals
.PP
This is a boolean operator that will return \f[C]true\f[R] if the LHS is
equal to the RHS and \f[C]false\f[R] otherwise.
.IP
.nf
\f[C]
\&.a == .b
\f[R]
.fi
.PP
It is most often used with the select operator to find particular nodes:
.IP
.nf
\f[C]
select(.a == .b)
\f[R]
.fi
.SS Match string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- goat
- dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] | (. == \[dq]*at\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
true
false
\f[R]
.fi
.SS Don\[cq]t match string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- goat
- dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] | (. != \[dq]*at\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
false
true
\f[R]
.fi
.SS Match number
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 3
- 4
- 5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] | (. == 4)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
true
false
\f[R]
.fi
.SS Dont match number
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 3
- 4
- 5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] | (. != 4)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
false
true
\f[R]
.fi
.SS Match nulls
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]null == \[ti]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS Non exisitant key doesn\[cq]t equal a value
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]select(.b != \[dq]thing\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.SS Two non existant keys are equal
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]select(.b == .c)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.SH File Operators
.PP
File operators are most often used with merge when needing to merge
specific files together.
Note that when doing this, you will need to use \f[C]eval-all\f[R] to
ensure all yaml documents are loaded into memory before performing the
merge (as opposed to \f[C]eval\f[R] which runs the expression once per
document).
.PP
Note that the \f[C]fileIndex\f[R] operator has a short alias of
\f[C]fi\f[R].
.SS Merging files
.PP
Note the use of eval-all to ensure all documents are loaded into memory.
.IP
.nf
\f[C]
yq eval-all \[aq]select(fi == 0) * select(filename == \[dq]file2.yaml\[dq])\[aq] file1.yaml file2.yaml
\f[R]
.fi
.SS Get filename
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]filename\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
sample.yml
\f[R]
.fi
.SS Get file index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]fileIndex\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
\f[R]
.fi
.SS Get file indices of multiple documents
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
And another sample another.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval-all \[aq]fileIndex\[aq] sample.yml another.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
---
1
\f[R]
.fi
.SS Get file index alias
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]fi\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
\f[R]
.fi
.SH Flatten
.PP
This recursively flattens arrays.
.SS Flatten
.PP
Recursively flattens all arrays
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- - 2
- - - 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]flatten\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.SS Flatten with depth of one
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- - 2
- - - 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]flatten(1)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 2
- - 3
\f[R]
.fi
.SS Flatten empty array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- []
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]flatten\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
[]
\f[R]
.fi
.SS Flatten array of objects
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- foo: bar
- - foo: baz
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]flatten\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- foo: bar
- foo: baz
\f[R]
.fi
.SH Group By
.PP
This is used to group items in an array by an expression.
.SS Group by field
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- foo: 1
  bar: 10
- foo: 3
  bar: 100
- foo: 1
  bar: 1
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]group_by(.foo)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- - foo: 1
    bar: 10
  - foo: 1
    bar: 1
- - foo: 3
    bar: 100
\f[R]
.fi
.SS Group by field, with nuls
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat: dog
- foo: 1
  bar: 10
- foo: 3
  bar: 100
- no: foo for you
- foo: 1
  bar: 1
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]group_by(.foo)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- - cat: dog
  - no: foo for you
- - foo: 1
    bar: 10
  - foo: 1
    bar: 1
- - foo: 3
    bar: 100
\f[R]
.fi
.SH Has
.PP
This is operation that returns true if the key exists in a map (or index
in an array), false otherwise.
.SS Has map key
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: yes
- a: \[ti]
- a:
- b: nope
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] | has(\[dq]a\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
true
true
false
\f[R]
.fi
.SS Select, checking for existence of deep paths
.PP
Simply pipe in parent expressions into \f[C]has\f[R]
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a:
    b:
      c: cat
- a:
    b:
      d: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] | select(.a.b | has(\[dq]c\[dq]))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b:
    c: cat
\f[R]
.fi
.SS Has array index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- []
- [1]
- [1, 2]
- [1, null]
- [1, 2, 3]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] | has(1)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
false
true
true
true
\f[R]
.fi
.SH Keys
.PP
Use the \f[C]keys\f[R] operator to return map keys or array indices.
.SS Map keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
dog: woof
cat: meow
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]keys\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- dog
- cat
\f[R]
.fi
.SS Array keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- apple
- banana
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]keys\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 0
- 1
\f[R]
.fi
.SH Length
.PP
Returns the lengths of the nodes.
Length is defined according to the type of the node.
.SS String length
.PP
returns length of string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a | length\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
3
\f[R]
.fi
.SS null length
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: null
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a | length\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
\f[R]
.fi
.SS Map length
.PP
returns number of entries
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
c: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]length\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
2
\f[R]
.fi
.SS Array length
.PP
returns number of elements
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 2
- 4
- 6
- 8
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]length\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
4
\f[R]
.fi
.SH Multiply (Merge)
.PP
Like the multiple operator in jq, depending on the operands, this
multiply operator will do different things.
Currently numbers, arrays and objects are supported.
.SS Objects and arrays - merging
.PP
Objects are merged deeply matching on matching keys.
By default, array values override and are not deeply merged.
.PP
Note that when merging objects, this operator returns the merged object
(not the parent).
This will be clearer in the examples below.
.SS Merge Flags
.PP
You can control how objects are merged by using one or more of the
following flags.
Multiple flags can be used together, e.g.\ \f[C].a *+? .b\f[R].
See examples below
.IP \[bu] 2
\f[C]+\f[R] to append arrays
.IP \[bu] 2
\f[C]?\f[R] to only merge existing fields
.IP \[bu] 2
\f[C]d\f[R] to deeply merge arrays
.SS Merging files
.PP
Note the use of \f[C]eval-all\f[R] to ensure all documents are loaded
into memory.
.IP
.nf
\f[C]
yq eval-all \[aq]select(fileIndex == 0) * select(fileIndex == 1)\[aq] file1.yaml file2.yaml
\f[R]
.fi
.SS Multiply integers
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]3 * 4\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
12
\f[R]
.fi
.SS Merge objects together, returning merged result only
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  field: me
  fieldA: cat
b:
  field:
    g: wizz
  fieldB: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a * .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
field:
  g: wizz
fieldA: cat
fieldB: dog
\f[R]
.fi
.SS Merge objects together, returning parent object
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  field: me
  fieldA: cat
b:
  field:
    g: wizz
  fieldB: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]. * {\[dq]a\[dq]:.b}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  field:
    g: wizz
  fieldA: cat
  fieldB: dog
b:
  field:
    g: wizz
  fieldB: dog
\f[R]
.fi
.SS Merge keeps style of LHS
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: {things: great}
b:
  also: \[dq]me\[dq]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]. * {\[dq]a\[dq]:.b}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: {things: great, also: \[dq]me\[dq]}
b:
  also: \[dq]me\[dq]
\f[R]
.fi
.SS Merge arrays
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - 1
  - 2
  - 3
b:
  - 3
  - 4
  - 5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]. * {\[dq]a\[dq]:.b}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  - 3
  - 4
  - 5
b:
  - 3
  - 4
  - 5
\f[R]
.fi
.SS Merge, only existing fields
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  thing: one
  cat: frog
b:
  missing: two
  thing: two
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a *? .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
thing: two
cat: frog
\f[R]
.fi
.SS Merge, appending arrays
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  array:
    - 1
    - 2
    - animal: dog
  value: coconut
b:
  array:
    - 3
    - 4
    - animal: cat
  value: banana
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a *+ .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
array:
  - 1
  - 2
  - animal: dog
  - 3
  - 4
  - animal: cat
value: banana
\f[R]
.fi
.SS Merge, only existing fields, appending arrays
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  thing:
    - 1
    - 2
b:
  thing:
    - 3
    - 4
  another:
    - 1
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a *?+ .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
thing:
  - 1
  - 2
  - 3
  - 4
\f[R]
.fi
.SS Merge, deeply merging arrays
.PP
Merging arrays deeply means arrays are merge like objects, with indexes
as their key.
In this case, we merge the first item in the array, and do nothing with
the second.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - name: fred
    age: 12
  - name: bob
    age: 32
b:
  - name: fred
    age: 34
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a *d .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- name: fred
  age: 34
- name: bob
  age: 32
\f[R]
.fi
.SS Merge arrays of objects together, matching on a key
.PP
It\[cq]s a complex command, the trickyness comes from needing to have
the right context in the expressions.
First we save the second array into a variable `$two' which lets us
reference it later.
We then need to update the first array.
We will use the relative update (|=) because we need to update relative
to the current element of the array in the LHS in the RHS expression.
We set the current element of the first array as $cur.
Now we multiply (merge) $cur with the matching entry in $two, by passing
$two through a select filter.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: apple
  b: appleB
- a: kiwi
  b: kiwiB
- a: banana
  b: bananaB
\f[R]
.fi
.PP
And another sample another.yml file of:
.IP
.nf
\f[C]
- a: banana
  c: bananaC
- a: apple
  b: appleB2
- a: dingo
  c: dingoC
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval-all \[aq](select(fi==1) | .[]) as $two | select(fi==0) | .[] |= (. as $cur |  $cur * ($two | select(.a == $cur.a)))\[aq] sample.yml another.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a: apple
  b: appleB2
- a: kiwi
  b: kiwiB
- a: banana
  b: bananaB
  c: bananaC
\f[R]
.fi
.SS Merge to prefix an element
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]. * {\[dq]a\[dq]: {\[dq]c\[dq]: .a}}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  c: cat
b: dog
\f[R]
.fi
.SS Merge with simple aliases
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: &cat
  c: frog
b:
  f: *cat
c:
  g: thongs
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].c * .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
g: thongs
f: *cat
\f[R]
.fi
.SS Merge copies anchor names
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  c: &cat frog
b:
  f: *cat
c:
  g: thongs
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].c * .a\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
g: thongs
c: &cat frog
\f[R]
.fi
.SS Merge with merge anchors
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].foobar * .foobarList\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
c: foobarList_c
!!merge <<:
  - *foo
  - *bar
thing: foobar_thing
b: foobarList_b
\f[R]
.fi
.SH Path
.PP
The path operator can be used to get the traversal paths of matching
nodes in an expression.
The path is returned as an array, which if traversed in order will lead
to the matching node.
.PP
You can get the key/index of matching nodes by using the \f[C]path\f[R]
operator to return the path array then piping that through
\f[C].[-1]\f[R] to get the last element of that array, the key.
.SS Map path
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.b | path\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a
- b
\f[R]
.fi
.SS Get map key
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.b | path | .[-1]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b
\f[R]
.fi
.SS Array path
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - cat
  - dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.[] | select(. == \[dq]dog\[dq]) | path\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a
- 1
\f[R]
.fi
.SS Get array index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - cat
  - dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.[] | select(. == \[dq]dog\[dq]) | path | .[-1]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
1
\f[R]
.fi
.SS Print path and value
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - cat
  - dog
  - frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.[] | select(. == \[dq]*og\[dq]) | [{\[dq]path\[dq]:path, \[dq]value\[dq]:.}]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- path:
    - a
    - 1
  value: dog
- path:
    - a
    - 2
  value: frog
\f[R]
.fi
.SH Pipe
.PP
Pipe the results of an expression into another.
Like the bash operator.
.SS Simple Pipe
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a | .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
\f[R]
.fi
.SS Multiple updates
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cow
b: sheep
c: same
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a = \[dq]cat\[dq] | .b = \[dq]dog\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b: dog
c: same
\f[R]
.fi
.SH Recursive Descent (Glob)
.PP
This operator recursively matches (or globs) all children nodes given of
a particular element, including that node itself.
This is most often used to apply a filter recursively against all
matches.
It can be used in either the
.SS match values form \f[C]..\f[R]
.PP
This will, like the \f[C]jq\f[R] equivalent, recursively match all
\f[I]value\f[R] nodes.
Use it to find/manipulate particular values.
.PP
For instance to set the \f[C]style\f[R] of all \f[I]value\f[R] nodes in
a yaml doc, excluding map keys:
.IP
.nf
\f[C]
yq eval \[aq].. style= \[dq]flow\[dq]\[aq] file.yaml
\f[R]
.fi
.SS match values and map keys form \f[C]...\f[R]
.PP
The also includes map keys in the results set.
This is particularly useful in YAML as unlike JSON, map keys can have
their own styling, tags and use anchors and aliases.
.PP
For instance to set the \f[C]style\f[R] of all nodes in a yaml doc,
including the map keys:
.IP
.nf
\f[C]
yq eval \[aq]... style= \[dq]flow\[dq]\[aq] file.yaml
\f[R]
.fi
.SS Recurse map (values only)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]..\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: frog
frog
\f[R]
.fi
.SS Recursively find nodes with keys
.PP
Note that this example has wrapped the expression in \f[C][]\f[R] to
show that there are two matches returned.
You do not have to wrap in \f[C][]\f[R] in your path expression.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  name: frog
  b:
    name: blog
    age: 12
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq][.. | select(has(\[dq]name\[dq]))]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- name: frog
  b:
    name: blog
    age: 12
- name: blog
  age: 12
\f[R]
.fi
.SS Recursively find nodes with values
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  nameA: frog
  b:
    nameB: frog
    age: 12
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].. | select(. == \[dq]frog\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
frog
frog
\f[R]
.fi
.SS Recurse map (values and keys)
.PP
Note that the map key appears in the results
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]...\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: frog
a
frog
\f[R]
.fi
.SS Aliases are not traversed
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: &cat
  c: frog
b: *cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq][..]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a: &cat
    c: frog
  b: *cat
- &cat
  c: frog
- frog
- *cat
\f[R]
.fi
.SS Merge docs are not traversed
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].foobar | [..]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
- foobar_c
- *foo
- foobar_thing
\f[R]
.fi
.SH Reduce
.PP
Reduce is a powerful way to process a collection of data into a new
form.
.IP
.nf
\f[C]
<exp> as $<name> ireduce (<init>; <block>)
\f[R]
.fi
.PP
e.g.
.IP
.nf
\f[C]
\&.[] as $item ireduce (0; . + $item)
\f[R]
.fi
.PP
On the LHS we are configuring the collection of items that will be
reduced \f[C]<exp>\f[R] as well as what each element will be called
\f[C]$<name>\f[R].
Note that the array has been splatted into its individual elements.
.PP
On the RHS there is \f[C]<init>\f[R], the starting value of the
accumulator and \f[C]<block>\f[R], the expression that will update the
accumulator for each element in the collection.
Note that within the block expression, \f[C].\f[R] will evaluate to the
current value of the accumulator.
.SS yq vs jq syntax
.PP
Reduce syntax in \f[C]yq\f[R] is a little different from \f[C]jq\f[R] -
as \f[C]yq\f[R] (currently) isn\[cq]t as sophisticated as \f[C]jq\f[R]
and its only supports infix notation (e.g.\ a + b, where the operator is
in the middle of the two parameters) - where as \f[C]jq\f[R] uses a mix
of infix notation with \f[I]prefix\f[R] notation
(e.g.\ \f[C]reduce a b\f[R] is like writing \f[C]+ a b\f[R]).
.PP
To that end, the reduce operator is called \f[C]ireduce\f[R] for
backwards compatability if a \f[C]jq\f[R] like prefix version of
\f[C]reduce\f[R] is ever added.
.SS Sum numbers
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 10
- 2
- 5
- 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] as $item ireduce (0; . + $item)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
20
\f[R]
.fi
.SS Merge all yaml files together
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
And another sample another.yml file of:
.IP
.nf
\f[C]
b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval-all \[aq]. as $item ireduce ({}; . * $item )\[aq] sample.yml another.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.SS Convert an array to an object
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- name: Cathy
  has: apples
- name: Bob
  has: bananas
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] as $item ireduce ({}; .[$item | .name] = ($item | .has) )\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
Cathy: apples
Bob: bananas
\f[R]
.fi
.SH Select
.PP
Select is used to filter arrays and maps by a boolean expression.
.SS Select elements from array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- goat
- dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] | select(. == \[dq]*at\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
goat
\f[R]
.fi
.SS Select and update matching values in map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  things: cat
  bob: goat
  horse: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq](.a.[] | select(. == \[dq]*at\[dq])) |= \[dq]rabbit\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  things: rabbit
  bob: rabbit
  horse: dog
\f[R]
.fi
.SH Sort Keys
.PP
The Sort Keys operator sorts maps by their keys (based on their string
value).
This operator does not do anything to arrays or scalars (so you can
easily recursively apply it to all maps).
.PP
Sort is particularly useful for diffing two different yaml documents:
.IP
.nf
\f[C]
yq eval -i \[aq]sortKeys(..)\[aq] file1.yml
yq eval -i \[aq]sortKeys(..)\[aq] file2.yml
diff file1.yml file2.yml
\f[R]
.fi
.SS Sort keys of map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
c: frog
a: blah
b: bing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]sortKeys(.)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: blah
b: bing
c: frog
\f[R]
.fi
.SS Sort keys recursively
.PP
Note the array elements are left unsorted, but maps inside arrays are
sorted
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
bParent:
  c: dog
  array:
    - 3
    - 1
    - 2
aParent:
  z: donkey
  x:
    - c: yum
      b: delish
    - b: ew
      a: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]sortKeys(..)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
aParent:
  x:
    - b: delish
      c: yum
    - a: apple
      b: ew
  z: donkey
bParent:
  array:
    - 3
    - 1
    - 2
  c: dog
\f[R]
.fi
.SH Split into Documents
.PP
This operator splits all matches into separate documents
.SS Split empty
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]splitDoc\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\f[R]
.fi
.SS Split array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: cat
- b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] | splitDoc\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
---
b: dog
\f[R]
.fi
.SH String Operators
.SS RegEx
.PP
This uses golangs native regex functions under the hood - See
https://github.com/google/re2/wiki/Syntax for the supported syntax.
.SS String blocks, bash and newlines
.PP
Bash is notorious for chomping on precious trailing newline characters,
making it tricky to set strings with newlines properly.
In particular, the \f[C]$( exp )\f[R] \f[I]will trim trailing
newlines\f[R].
.PP
For instance to get this yaml:
.IP
.nf
\f[C]
a: |
  cat
\f[R]
.fi
.PP
Using \f[C]$( exp )\f[R] wont work, as it will trim the trailing new
line.
.IP
.nf
\f[C]
m=$(echo \[dq]cat\[rs]n\[dq]) yq e -n \[aq].a = strenv(m)\[aq]
a: cat
\f[R]
.fi
.PP
However, using printf works:
.IP
.nf
\f[C]
printf -v m \[dq]cat\[rs]n\[dq] ; m=\[dq]$m\[dq] yq e -n \[aq].a = strenv(m)\[aq]
a: |
  cat
\f[R]
.fi
.PP
As well as having multiline expressions:
.IP
.nf
\f[C]
m=\[dq]cat
\[dq]  yq e -n \[aq].a = strenv(m)\[aq]
a: |
  cat
\f[R]
.fi
.PP
Similarly, if you\[cq]re trying to set the content from a file, and want
a trailing new line:
.IP
.nf
\f[C]
IFS= read -rd \[aq]\[aq] output < <(cat my_file)
output=$output ./yq e \[aq].data.values = strenv(output)\[aq] first.yml
\f[R]
.fi
.SS Join strings
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- meow
- 1
- null
- true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]join(\[dq]; \[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat; meow; 1; ; true
\f[R]
.fi
.SS Match string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo bar foo
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]match(\[dq]foo\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
string: foo
offset: 0
length: 3
captures: []
\f[R]
.fi
.SS Match string, case insensitive
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo bar FOO
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq][match(\[dq](?i)foo\[dq]; \[dq]g\[dq])]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- string: foo
  offset: 0
  length: 3
  captures: []
- string: FOO
  offset: 8
  length: 3
  captures: []
\f[R]
.fi
.SS Match with capture groups
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
abc abc
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq][match(\[dq](abc)+\[dq]; \[dq]g\[dq])]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- string: abc
  offset: 0
  length: 3
  captures:
    - string: abc
      offset: 0
      length: 3
- string: abc
  offset: 4
  length: 3
  captures:
    - string: abc
      offset: 4
      length: 3
\f[R]
.fi
.SS Match with named capture groups
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo bar foo foo  foo
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq][match(\[dq]foo (?P<bar123>bar)? foo\[dq]; \[dq]g\[dq])]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- string: foo bar foo
  offset: 0
  length: 11
  captures:
    - string: bar
      offset: 4
      length: 3
      name: bar123
- string: foo  foo
  offset: 12
  length: 8
  captures:
    - string: null
      offset: -1
      length: 0
      name: bar123
\f[R]
.fi
.SS Capture named groups into a map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
xyzzy-14
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]capture(\[dq](?P<a>[a-z]+)-(?P<n>[0-9]+)\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: xyzzy
n: \[dq]14\[dq]
\f[R]
.fi
.SS Match without global flag
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]match(\[dq]cat\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
string: cat
offset: 0
length: 3
captures: []
\f[R]
.fi
.SS Match with global flag
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq][match(\[dq]cat\[dq]; \[dq]g\[dq])]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- string: cat
  offset: 0
  length: 3
  captures: []
- string: cat
  offset: 4
  length: 3
  captures: []
\f[R]
.fi
.SS Test using regex
.PP
Like jq\[cq]q equivalant, this works like match but only returns
true/false instead of full match details
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] | test(\[dq]at\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
false
\f[R]
.fi
.SS Substitute / Replace string
.PP
This uses golang regex, described
here (https://github.com/google/re2/wiki/Syntax) Note the use of
\f[C]|=\f[R] to run in context of the current string value.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: dogs are great
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a |= sub(\[dq]dogs\[dq], \[dq]cats\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cats are great
\f[R]
.fi
.SS Substitute / Replace string with regex
.PP
This uses golang regex, described
here (https://github.com/google/re2/wiki/Syntax) Note the use of
\f[C]|=\f[R] to run in context of the current string value.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: heat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] |= sub(\[dq](a)\[dq], \[dq]${1}r\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cart
b: heart
\f[R]
.fi
.SS Split strings
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat; meow; 1; ; true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]split(\[dq]; \[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- cat
- meow
- \[dq]1\[dq]
- \[dq]\[dq]
- \[dq]true\[dq]
\f[R]
.fi
.SS Split strings one match
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
word
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]split(\[dq]; \[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- word
\f[R]
.fi
.SH Style
.PP
The style operator can be used to get or set the style of nodes
(e.g.\ string style, yaml style)
.SS Update and set style of a particular node (simple)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: thing
  c: something
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.b = \[dq]new\[dq] | .a.b style=\[dq]double\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: \[dq]new\[dq]
  c: something
\f[R]
.fi
.SS Update and set style of a particular node using path variables
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: thing
  c: something
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]with(.a.b ; . = \[dq]new\[dq] | . style=\[dq]double\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: \[dq]new\[dq]
  c: something
\f[R]
.fi
.SS Set tagged style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].. style=\[dq]tagged\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
!!map
a: !!str cat
b: !!int 5
c: !!float 3.2
e: !!bool true
\f[R]
.fi
.SS Set double quote style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].. style=\[dq]double\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[dq]cat\[dq]
b: \[dq]5\[dq]
c: \[dq]3.2\[dq]
e: \[dq]true\[dq]
\f[R]
.fi
.SS Set double quote style on map keys too
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]... style=\[dq]double\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\[dq]a\[dq]: \[dq]cat\[dq]
\[dq]b\[dq]: \[dq]5\[dq]
\[dq]c\[dq]: \[dq]3.2\[dq]
\[dq]e\[dq]: \[dq]true\[dq]
\f[R]
.fi
.SS Set single quote style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].. style=\[dq]single\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[aq]cat\[aq]
b: \[aq]5\[aq]
c: \[aq]3.2\[aq]
e: \[aq]true\[aq]
\f[R]
.fi
.SS Set literal quote style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].. style=\[dq]literal\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: |-
  cat
b: |-
  5
c: |-
  3.2
e: |-
  true
\f[R]
.fi
.SS Set folded quote style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].. style=\[dq]folded\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: >-
  cat
b: >-
  5
c: >-
  3.2
e: >-
  true
\f[R]
.fi
.SS Set flow quote style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].. style=\[dq]flow\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
{a: cat, b: 5, c: 3.2, e: true}
\f[R]
.fi
.SS Reset style - or pretty print
.PP
Set empty (default) quote style, note the usage of \f[C]...\f[R] to
match keys too.
Note that there is a \f[C]--prettyPrint/-P\f[R] short flag for this.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\[dq]b\[dq]: 5
\[aq]c\[aq]: 3.2
\[dq]e\[dq]: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]... style=\[dq]\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.SS Set style relatively with assign-update
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: single
b: double
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] style |= .\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[aq]single\[aq]
b: \[dq]double\[dq]
\f[R]
.fi
.SS Read style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
{a: \[dq]cat\[dq], b: \[aq]thing\[aq]}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].. | style\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
flow
double
single
\f[R]
.fi
.SH Subtract
.PP
You can use subtract to subtract numbers, as well as removing elements
from an array.
.SS Array subtraction
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq][1,2] - [2,3]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
\f[R]
.fi
.SS Array subtraction with nested array
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq][[1], 1, 2] - [[1], 3]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 2
\f[R]
.fi
.SS Array subtraction with nested object
.PP
Note that order of the keys does not matter
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: b
  c: d
- a: b
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]. - [{\[dq]c\[dq]: \[dq]d\[dq], \[dq]a\[dq]: \[dq]b\[dq]}]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a: b
\f[R]
.fi
.SS Number subtraction - float
.PP
If the lhs or rhs are floats then the expression will be calculated with
floats.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 4.5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a = .a - .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: -1.5
b: 4.5
\f[R]
.fi
.SS Number subtraction - float
.PP
If the lhs or rhs are floats then the expression will be calculated with
floats.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 4.5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a = .a - .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: -1.5
b: 4.5
\f[R]
.fi
.SS Number subtraction - int
.PP
If both the lhs and rhs are ints then the expression will be calculated
with ints.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a = .a - .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: -1
b: 4
\f[R]
.fi
.SS Decrement numbers
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] -= 1\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 2
b: 4
\f[R]
.fi
.SH Tag
.PP
The tag operator can be used to get or set the tag of nodes
(e.g.\ \f[C]!!str\f[R], \f[C]!!int\f[R], \f[C]!!bool\f[R]).
.SS Get tag
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
f: []
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].. | tag\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
!!map
!!str
!!int
!!float
!!bool
!!seq
\f[R]
.fi
.SS Set custom tag
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: str
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a tag = \[dq]!!mikefarah\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: !!mikefarah str
\f[R]
.fi
.SS Find numbers and convert them to strings
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq](.. | select(tag == \[dq]!!int\[dq])) tag= \[dq]!!str\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b: \[dq]5\[dq]
c: 3.2
e: true
\f[R]
.fi
.SH Traverse (Read)
.PP
This is the simplest (and perhaps most used) operator, it is used to
navigate deeply into yaml structures.
.SS Simple map navigation
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b: apple
\f[R]
.fi
.SS Splat
.PP
Often used to pipe children into other operators
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- b: apple
- c: banana
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b: apple
c: banana
\f[R]
.fi
.SS Optional Splat
.PP
Just like splat, but won\[cq]t error if you run it against scalars
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\f[R]
.fi
.SS Special characters
.PP
Use quotes with brackets around path elements with special characters
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
\[dq]{}\[dq]: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[\[dq]{}\[dq]]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
frog
\f[R]
.fi
.SS Nested special characters
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  \[dq]key.withdots\[dq]:
    \[dq]another.key\[dq]: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a[\[dq]key.withdots\[dq]][\[dq]another.key\[dq]]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
apple
\f[R]
.fi
.SS Keys with spaces
.PP
Use quotes with brackets around path elements with special characters
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
\[dq]red rabbit\[dq]: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[\[dq]red rabbit\[dq]]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
frog
\f[R]
.fi
.SS Dynamic keys
.PP
Expressions within [] can be used to dynamically lookup / calculate keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
b: apple
apple: crispy yum
banana: soft yum
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[.b]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
crispy yum
\f[R]
.fi
.SS Children don\[cq]t exist
.PP
Nodes are added dynamically while traversing
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
c: banana
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
null
\f[R]
.fi
.SS Optional identifier
.PP
Like jq, does not output an error when the yaml is not an array or
object as expected
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a?\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\f[R]
.fi
.SS Wildcard matching
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cat: apple
  mad: things
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.\[dq]*a*\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
apple
things
\f[R]
.fi
.SS Aliases
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: &cat
  c: frog
b: *cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
*cat
\f[R]
.fi
.SS Traversing aliases with splat
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: &cat
  c: frog
b: *cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].b[]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
frog
\f[R]
.fi
.SS Traversing aliases explicitly
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: &cat
  c: frog
b: *cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].b.c\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
frog
\f[R]
.fi
.SS Traversing arrays by index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[0]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
1
\f[R]
.fi
.SS Traversing nested arrays by index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
[[], [cat]]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[1][0]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
\f[R]
.fi
.SS Maps with numeric keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
2: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[2]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
\f[R]
.fi
.SS Maps with non existing numeric keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: b
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[0]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
null
\f[R]
.fi
.SS Traversing merge anchors
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].foobar.a\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
foo_a
\f[R]
.fi
.SS Traversing merge anchors with override
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].foobar.c\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
foo_c
\f[R]
.fi
.SS Traversing merge anchors with local override
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].foobar.thing\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
foobar_thing
\f[R]
.fi
.SS Splatting merge anchors
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].foobar[]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
foo_c
foo_a
foobar_thing
\f[R]
.fi
.SS Traversing merge anchor lists
.PP
Note that the later merge anchors override previous
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].foobarList.thing\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
bar_thing
\f[R]
.fi
.SS Splatting merge anchor lists
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].foobarList[]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
bar_b
foo_a
bar_thing
foobarList_c
\f[R]
.fi
.SS Select multiple indices
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - a
  - b
  - c
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a[0, 2]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a
c
\f[R]
.fi
.SH Union
.PP
This operator is used to combine different results together.
.SS Combine scalars
.PP
Running
.IP
.nf
\f[C]
yq eval --null-input \[aq]1, true, \[dq]cat\[dq]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
1
true
cat
\f[R]
.fi
.SS Combine selected paths
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: fieldA
b: fieldB
c: fieldC
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a, .c\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
fieldA
fieldC
\f[R]
.fi
.SH Unique
.PP
This is used to filter out duplicated items in an array.
.SS Unique array of scalars (string/numbers)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- 2
- 3
- 2
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]unique\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.SS Unique nulls
.PP
Unique works on the node value, so it considers different
representations of nulls to be different
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- \[ti]
- null
- \[ti]
- null
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]unique\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- \[ti]
- null
\f[R]
.fi
.SS Unique all nulls
.PP
Run against the node tag to unique all the nulls
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- \[ti]
- null
- \[ti]
- null
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]unique_by(tag)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- \[ti]
\f[R]
.fi
.SS Unique array object fields
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- name: harry
  pet: cat
- name: billy
  pet: dog
- name: harry
  pet: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]unique_by(.name)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- name: harry
  pet: cat
- name: billy
  pet: dog
\f[R]
.fi
.SH Variable Operators
.PP
Like the \f[C]jq\f[R] equivalents, variables are sometimes required for
the more complex expressions (or swapping values between fields).
.PP
Note that there is also an additional \f[C]ref\f[R] operator that holds
a reference (instead of a copy) of the path, allowing you to make
multiple changes to the same path.
.SS Single value variable
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a as $foo | $foo\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
\f[R]
.fi
.SS Multi value variable
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].[] as $foo | $foo\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
dog
\f[R]
.fi
.SS Using variables as a lookup
.PP
Example taken from
jq (https://stedolan.github.io/jq/manual/#Variable/SymbolicBindingOperator:...as$identifier%7C...)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
\[dq]posts\[dq]:
  - \[dq]title\[dq]: Frist psot
    \[dq]author\[dq]: anon
  - \[dq]title\[dq]: A well-written article
    \[dq]author\[dq]: person1
\[dq]realnames\[dq]:
  \[dq]anon\[dq]: Anonymous Coward
  \[dq]person1\[dq]: Person McPherson
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].realnames as $names | .posts[] | {\[dq]title\[dq]:.title, \[dq]author\[dq]: $names[.author]}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
title: Frist psot
author: Anonymous Coward
title: A well-written article
author: Person McPherson
\f[R]
.fi
.SS Using variables to swap values
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: a_value
b: b_value
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a as $x  | .b as $y | .b = $x | .a = $y\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: b_value
b: a_value
\f[R]
.fi
.SS Use ref to reference a path repeatedly
.PP
Note: You may find the \f[C]with\f[R] operator more useful.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: thing
  c: something
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq].a.b ref $x | $x = \[dq]new\[dq] | $x style=\[dq]double\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: \[dq]new\[dq]
  c: something
\f[R]
.fi
.SH With
.PP
Use the \f[C]with\f[R] operator to conveniently make multiple updates to
a deeply nested path, or to update array elements relatively to each
other.
The first argument expression sets the root context, and the second
expression runs against that root context.
.SS Update and style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  deeply:
    nested: value
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]with(.a.deeply.nested; . = \[dq]newValue\[dq] | . style=\[dq]single\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  deeply:
    nested: \[aq]newValue\[aq]
\f[R]
.fi
.SS Update multiple deeply nested properties
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  deeply:
    nested: value
    other: thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]with(.a.deeply; .nested = \[dq]newValue\[dq] | .other= \[dq]newThing\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  deeply:
    nested: newValue
    other: newThing
\f[R]
.fi
.SS Update array elements relatively
.PP
The second expression runs with each element of the array as it\[cq]s
contextual root.
This allows you to make updates relative to the element.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
myArray:
  - a: apple
  - a: banana
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval \[aq]with(.myArray[]; .b = .a + \[dq] yum\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
myArray:
  - a: apple
    b: apple yum
  - a: banana
    b: banana yum
\f[R]
.fi
.SH AUTHORS
Mike Farah.
